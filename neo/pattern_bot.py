#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NEO PATTERN BOT - Autonomous Trading Based on Backtest Patterns
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Unlike Ghost Commander (which follows NEO's LLM signals), this bot runs
AUTONOMOUSLY using statistical patterns from 12-month XAUUSD backtest.

Key Features:
- Day of Week patterns (Monday 66% bullish, etc.)
- Session patterns (London 73% sets day direction)
- Indicator patterns (RSI extremes)
- Volatility-adjusted position sizing
- Crowd psychology risk filter

Magic Number: 777002 (Ghost Commander = 777001)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import asyncio
import aiohttp
import json
import logging
import os
import sys
from datetime import datetime, timedelta, time as dt_time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
import traceback

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from pattern_config import (
    DAY_RULES, SESSION_RULES, POSITION_SIZING, TP_SL_RULES,
    INDICATOR_RULES, CROWD_PSYCHOLOGY_RULES, BOT_CONFIG,
    get_current_session, get_session_strategy, get_day_bias,
    should_trade_day, get_tp_sl, calculate_lot_size
)
from weekly_predictions import get_trading_plan, get_pattern_context

# Try to import crowd psychology
try:
    from crowd_psychology import get_crowd_psychology
    CROWD_PSYCH_AVAILABLE = True
except ImportError:
    CROWD_PSYCH_AVAILABLE = False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGGING SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

os.makedirs(os.path.dirname(BOT_CONFIG.log_file), exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler(BOT_CONFIG.log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(BOT_CONFIG.bot_name)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA STRUCTURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class TradeSignal:
    """A trade signal generated by pattern analysis"""
    direction: str          # BUY or SELL
    reason: str             # Human-readable reason
    pattern_id: str         # Pattern identifier
    confidence: float       # 0-100
    win_rate: float         # Historical win rate
    entry_price: float      # Target entry
    stop_loss: float        # Stop loss price
    take_profit: float      # Take profit price
    lot_size: float         # Position size
    day_rule: str           # Day of week pattern
    session_rule: str       # Session pattern
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


@dataclass
class BotState:
    """Current bot state"""
    is_running: bool = False
    is_paused: bool = False
    cycle_count: int = 0
    daily_trades: int = 0
    daily_pnl: float = 0.0
    last_trade_time: datetime = None
    open_positions: List[Dict] = None
    last_error: str = None
    
    def __post_init__(self):
        if self.open_positions is None:
            self.open_positions = []


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MT5 API CLIENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MT5Client:
    """Client for MT5 Trades API"""
    
    def __init__(self, base_url: str = BOT_CONFIG.mt5_api_url):
        self.base_url = base_url
        self.session: aiohttp.ClientSession = None
    
    async def _ensure_session(self):
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession()
    
    async def close(self):
        if self.session and not self.session.closed:
            await self.session.close()
    
    async def get_price(self, symbol: str = "XAUUSD") -> Optional[Dict]:
        """Get current price for symbol"""
        await self._ensure_session()
        try:
            # First try direct price endpoint
            async with self.session.get(
                f"{self.base_url}/price/{symbol}",
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
        except:
            pass
        
        # Fallback: Get price from gold signal endpoint
        try:
            async with self.session.get(
                f"{self.base_url}/neo/gold/signal",
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    if data.get("trade_plan", {}).get("current_price"):
                        return {"price": data["trade_plan"]["current_price"]}
        except:
            pass
        
        # Final fallback: Use yfinance
        try:
            import yfinance as yf
            ticker = yf.Ticker("GC=F")
            data = ticker.history(period="1d")
            if not data.empty:
                return {"price": float(data['Close'].iloc[-1])}
        except Exception as e:
            logger.error(f"Failed to get price: {e}")
        
        return None
    
    async def get_positions(self, magic: int = BOT_CONFIG.magic_number) -> List[Dict]:
        """Get open positions for this bot"""
        await self._ensure_session()
        try:
            async with self.session.get(
                f"{self.base_url}/positions",
                params={"magic": magic},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return data.get("positions", [])
        except Exception as e:
            logger.error(f"Failed to get positions: {e}")
        return []
    
    async def place_order(self, order: Dict) -> Dict:
        """Place a new order"""
        await self._ensure_session()
        try:
            async with self.session.post(
                f"{self.base_url}/trade/open",
                json=order,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as resp:
                result = await resp.json()
                return result
        except Exception as e:
            logger.error(f"Failed to place order: {e}")
            return {"success": False, "error": str(e)}
    
    async def close_position(self, ticket: int, reason: str = "") -> Dict:
        """Close a position"""
        await self._ensure_session()
        try:
            async with self.session.post(
                f"{self.base_url}/trade/close",
                json={"ticket": ticket, "reason": reason},
                timeout=aiohttp.ClientTimeout(total=30)
            ) as resp:
                return await resp.json()
        except Exception as e:
            logger.error(f"Failed to close position: {e}")
            return {"success": False, "error": str(e)}
    
    async def get_account_info(self) -> Optional[Dict]:
        """Get account information"""
        await self._ensure_session()
        try:
            async with self.session.get(
                f"{self.base_url}/account",
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
        except Exception as e:
            logger.error(f"Failed to get account info: {e}")
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN ANALYZER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PatternAnalyzer:
    """Analyzes current market conditions against backtest patterns"""
    
    def __init__(self):
        self.last_price_data = None
    
    def get_current_context(self) -> Dict:
        """Get current day/session/time context"""
        now = datetime.utcnow()
        day_name = now.strftime("%A")
        hour = now.hour
        session = get_current_session(hour)
        
        return {
            "timestamp": now.isoformat(),
            "day_name": day_name,
            "hour": hour,
            "session": session,
            "day_rules": DAY_RULES.get(day_name, {}),
            "session_rules": SESSION_RULES.get(session, {})
        }
    
    def should_trade_now(self, context: Dict) -> Tuple[bool, str]:
        """Check if we should be trading right now"""
        day_name = context["day_name"]
        hour = context["hour"]
        day_rules = context["day_rules"]
        session_rules = context["session_rules"]
        
        # Check if trading allowed today
        if not day_rules.get("trade", False):
            return False, f"No trading on {day_name}"
        
        # Check Friday cutoff
        if day_name == "Friday":
            cutoff = day_rules.get("trade_cutoff_hour", 16)
            if hour >= cutoff:
                return False, f"Friday cutoff reached ({cutoff}:00 UTC)"
        
        # Check Wednesday FOMC hours
        if day_name == "Wednesday":
            avoid_hours = day_rules.get("avoid_hours", [])
            if hour in avoid_hours:
                return False, f"Avoiding FOMC hours ({hour}:00 UTC)"
        
        # Check late NY session
        if session_rules.get("strategy") == "NO_TRADE":
            return False, "Late NY session - low liquidity"
        
        return True, "Trading allowed"
    
    def analyze_patterns(
        self, 
        context: Dict, 
        price: float,
        rsi_14: float = None,
        rsi_2: float = None,
        crowd_psychology: Dict = None
    ) -> Optional[TradeSignal]:
        """
        Analyze current conditions against backtest patterns.
        Returns a trade signal if patterns align.
        """
        day_name = context["day_name"]
        session = context["session"]
        day_rules = context["day_rules"]
        session_rules = context["session_rules"]
        
        # Get trading plan from weekly predictions
        plan = get_trading_plan(day_of_week=day_name, session=session, current_price=price)
        
        # Check crowd psychology filter
        if crowd_psychology and crowd_psychology.get("available"):
            crash_prob = crowd_psychology.get("crash_probability", 0)
            thresholds = CROWD_PSYCHOLOGY_RULES["crash_probability"]
            
            if crash_prob >= thresholds["red_light"]:
                logger.info(f"âš ï¸ Crowd psychology red light: {crash_prob}% crash probability")
                return None
        
        # Build confidence score
        confidence = plan.get("confidence", 50)
        win_rate = day_rules.get("win_rate", 0.50)
        
        # Check minimum thresholds
        if confidence < BOT_CONFIG.min_confidence:
            return None
        if win_rate < BOT_CONFIG.min_win_rate:
            return None
        
        # Determine direction based on patterns
        direction = None
        reason = []
        pattern_id = None
        
        # Pattern 1: Monday Bullish Bias (66% win rate)
        if day_name == "Monday" and day_rules.get("win_rate", 0) >= 0.65:
            direction = "BUY"
            reason.append(f"Monday bullish bias ({day_rules['win_rate']*100:.0f}%)")
            pattern_id = "monday_bullish"
            confidence = max(confidence, 66)
        
        # Pattern 2: London Sets Day Direction (73% accurate)
        elif session == "LONDON" and session_rules.get("sets_day_direction"):
            # Follow London breakout direction
            direction = plan.get("bias", "NEUTRAL")
            if direction == "BULLISH":
                direction = "BUY"
            elif direction == "BEARISH":
                direction = "SELL"
            else:
                direction = None
            
            if direction:
                reason.append(f"London breakout ({session_rules['trend_accuracy']*100:.0f}% sets day)")
                pattern_id = "london_breakout"
                confidence = max(confidence, 73)
        
        # Pattern 3: Thursday Gap Fill (60% rate)
        elif day_name == "Thursday" and day_rules.get("gap_fill_rate", 0) >= 0.55:
            # Would need gap data to determine direction
            # For now, use the bias from predictions
            bias = plan.get("bias", "NEUTRAL")
            if bias != "NEUTRAL":
                direction = "BUY" if bias == "BULLISH" else "SELL"
                reason.append(f"Thursday pattern ({day_rules['gap_fill_rate']*100:.0f}% gap fill)")
                pattern_id = "thursday_gap"
        
        # Pattern 4: RSI Extreme Readings
        if rsi_2 is not None:
            rsi_rules = INDICATOR_RULES["rsi_2"]
            if rsi_2 < rsi_rules["extreme_low"]:
                direction = "BUY"
                reason.append(f"RSI(2) extreme low ({rsi_2:.0f})")
                pattern_id = "rsi2_extreme_low"
                confidence = max(confidence, 65)
            elif rsi_2 > rsi_rules["extreme_high"]:
                direction = "SELL"
                reason.append(f"RSI(2) extreme high ({rsi_2:.0f})")
                pattern_id = "rsi2_extreme_high"
                confidence = max(confidence, 60)
        
        # Pattern 5: Friday Afternoon Fade
        if day_name == "Friday" and context["hour"] >= 14:
            if plan.get("bias") == "BULLISH":
                # Fade extended moves on Friday afternoon
                direction = "SELL" if plan.get("expected_range", 0) > 30 else None
                if direction:
                    reason.append("Friday afternoon fade")
                    pattern_id = "friday_fade"
        
        # If no direction determined, skip
        if direction is None or direction not in ["BUY", "SELL"]:
            return None
        
        # Get TP/SL from volatility regime
        vol_regime = "NORMAL_VOL"  # Would determine from ATR
        tp_sl = get_tp_sl(vol_regime, day_name)
        
        # Calculate prices
        sl_points = tp_sl["sl"]
        tp_points = tp_sl["tp"]
        
        if direction == "BUY":
            stop_loss = price - sl_points
            take_profit = price + tp_points
        else:
            stop_loss = price + sl_points
            take_profit = price - tp_points
        
        # Calculate lot size
        account_balance = 10000  # Would get from MT5
        lot_size = calculate_lot_size(confidence, win_rate, account_balance, sl_points)
        
        return TradeSignal(
            direction=direction,
            reason=" | ".join(reason),
            pattern_id=pattern_id or "combined",
            confidence=confidence,
            win_rate=win_rate,
            entry_price=price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            lot_size=lot_size,
            day_rule=day_rules.get("bias", "NEUTRAL"),
            session_rule=session_rules.get("strategy", "NEUTRAL")
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NEO PATTERN BOT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NeoPatternBot:
    """
    Autonomous trading bot based on backtest patterns.
    Runs independently of NEO's LLM signals.
    """
    
    def __init__(self):
        self.mt5 = MT5Client()
        self.analyzer = PatternAnalyzer()
        self.state = BotState()
        self.symbol = "XAUUSD"
        
        logger.info("")
        logger.info("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        logger.info("â•‘           NEO PATTERN BOT - Autonomous Trader                â•‘")
        logger.info("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        logger.info(f"â•‘  Symbol:        {self.symbol:<42}  â•‘")
        logger.info(f"â•‘  Magic Number:  {BOT_CONFIG.magic_number:<42}  â•‘")
        logger.info(f"â•‘  Max Trades:    {BOT_CONFIG.max_daily_trades}/day                                     â•‘")
        logger.info(f"â•‘  Check Interval: {BOT_CONFIG.check_interval_seconds}s                                       â•‘")
        logger.info("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        logger.info("")
    
    async def run(self):
        """Main bot loop - runs continuously"""
        self.state.is_running = True
        logger.info("ğŸ¤– Pattern Bot starting...")
        
        try:
            while self.state.is_running:
                try:
                    await self.cycle()
                except Exception as e:
                    logger.error(f"Cycle error: {e}")
                    self.state.last_error = str(e)
                    traceback.print_exc()
                
                await asyncio.sleep(BOT_CONFIG.check_interval_seconds)
                
        finally:
            await self.mt5.close()
            logger.info("ğŸ¤– Pattern Bot stopped")
    
    async def cycle(self):
        """Single check cycle"""
        self.state.cycle_count += 1
        now = datetime.utcnow()
        
        # Reset daily counters at midnight UTC
        if now.hour == 0 and now.minute == 0:
            self.state.daily_trades = 0
            self.state.daily_pnl = 0.0
            logger.info("ğŸ“† New trading day - counters reset")
        
        # Log cycle
        if self.state.cycle_count % 10 == 1:  # Log every 10 cycles
            logger.info("")
            logger.info("=" * 60)
            logger.info(f"ğŸ¤– CYCLE {self.state.cycle_count} - {now.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            logger.info("=" * 60)
        
        # Check if paused
        if self.state.is_paused:
            if self.state.cycle_count % 60 == 1:  # Log every minute
                logger.info("â¸ï¸ Bot is paused")
            return
        
        # Check daily trade limit
        if self.state.daily_trades >= BOT_CONFIG.max_daily_trades:
            if self.state.cycle_count % 60 == 1:
                logger.info(f"ğŸ“Š Max daily trades reached ({self.state.daily_trades}). Waiting...")
            return
        
        # Check time between trades
        if self.state.last_trade_time:
            seconds_since = (now - self.state.last_trade_time).total_seconds()
            if seconds_since < BOT_CONFIG.min_time_between_trades:
                return  # Too soon for another trade
        
        # Get current context
        context = self.analyzer.get_current_context()
        
        # Check if we should trade now
        can_trade, reason = self.analyzer.should_trade_now(context)
        if not can_trade:
            if self.state.cycle_count % 60 == 1:
                logger.info(f"â³ {reason}")
            return
        
        # Get current positions
        self.state.open_positions = await self.mt5.get_positions()
        
        # Check max positions
        if len(self.state.open_positions) >= BOT_CONFIG.max_positions:
            if self.state.cycle_count % 60 == 1:
                logger.info(f"ğŸ“Š Max positions reached ({len(self.state.open_positions)})")
            return
        
        # Check if already have position in this symbol
        if POSITION_SIZING.one_per_symbol:
            for pos in self.state.open_positions:
                if pos.get("symbol") == self.symbol:
                    return  # Already have position
        
        # Get current price
        price_data = await self.mt5.get_price(self.symbol)
        if not price_data or "price" not in price_data:
            logger.warning("Failed to get price data")
            return
        
        current_price = price_data["price"]
        
        # Get crowd psychology (if available)
        crowd = None
        if CROWD_PSYCH_AVAILABLE:
            try:
                crowd = get_crowd_psychology(self.symbol)
            except:
                pass
        
        # Analyze patterns and generate signal
        signal = self.analyzer.analyze_patterns(
            context=context,
            price=current_price,
            crowd_psychology=crowd
        )
        
        if signal is None:
            return  # No valid signal
        
        # Execute the trade
        await self.execute_trade(signal)
    
    async def execute_trade(self, signal: TradeSignal):
        """Execute a trade based on the signal"""
        logger.info("")
        logger.info("ğŸ¯ TRADE SIGNAL DETECTED")
        logger.info(f"   Pattern: {signal.pattern_id}")
        logger.info(f"   Direction: {signal.direction}")
        logger.info(f"   Confidence: {signal.confidence:.0f}%")
        logger.info(f"   Win Rate: {signal.win_rate*100:.0f}%")
        logger.info(f"   Entry: ${signal.entry_price:.2f}")
        logger.info(f"   SL: ${signal.stop_loss:.2f}")
        logger.info(f"   TP: ${signal.take_profit:.2f}")
        logger.info(f"   Lot: {signal.lot_size}")
        logger.info(f"   Reason: {signal.reason}")
        
        # Build order
        order = {
            "symbol": self.symbol,
            "action": signal.direction,
            "volume": signal.lot_size,
            "stop_loss": signal.stop_loss,
            "take_profit": signal.take_profit,
            "magic": BOT_CONFIG.magic_number,
            "comment": f"PatternBot: {signal.pattern_id} ({signal.confidence:.0f}%)",
            "source": "NEO_PATTERN_BOT"
        }
        
        # Execute
        result = await self.mt5.place_order(order)
        
        if result.get("success"):
            self.state.daily_trades += 1
            self.state.last_trade_time = datetime.utcnow()
            
            logger.info("âœ… TRADE EXECUTED")
            logger.info(f"   Ticket: {result.get('ticket', 'N/A')}")
            logger.info(f"   Daily trades: {self.state.daily_trades}/{BOT_CONFIG.max_daily_trades}")
            
            # Broadcast to Redis for Telegram
            await self.broadcast_trade(signal, result)
        else:
            logger.error(f"âŒ Trade failed: {result.get('error', 'Unknown error')}")
    
    async def broadcast_trade(self, signal: TradeSignal, result: Dict):
        """Broadcast trade to Telegram via Redis"""
        try:
            import redis
            r = redis.Redis(host='localhost', port=6379)
            
            message = {
                "agent": "NEO_PATTERN_BOT",
                "type": "trade",
                "data": {
                    "action": signal.direction,
                    "symbol": self.symbol,
                    "entry_price": signal.entry_price,
                    "stop_loss": signal.stop_loss,
                    "take_profit": signal.take_profit,
                    "lot_size": signal.lot_size,
                    "pattern": signal.pattern_id,
                    "confidence": signal.confidence,
                    "win_rate": signal.win_rate,
                    "reason": signal.reason,
                    "ticket": result.get("ticket")
                },
                "timestamp": datetime.utcnow().isoformat()
            }
            
            r.publish("human:alerts", json.dumps(message))
            logger.info("ğŸ“¤ Trade broadcast to Telegram")
            
        except Exception as e:
            logger.warning(f"Failed to broadcast: {e}")
    
    def pause(self):
        """Pause the bot"""
        self.state.is_paused = True
        logger.info("â¸ï¸ Bot paused")
    
    def resume(self):
        """Resume the bot"""
        self.state.is_paused = False
        logger.info("â–¶ï¸ Bot resumed")
    
    def stop(self):
        """Stop the bot"""
        self.state.is_running = False
        logger.info("ğŸ›‘ Bot stopping...")
    
    def get_status(self) -> Dict:
        """Get current bot status"""
        context = self.analyzer.get_current_context()
        
        return {
            "bot_name": BOT_CONFIG.bot_name,
            "is_running": self.state.is_running,
            "is_paused": self.state.is_paused,
            "cycle_count": self.state.cycle_count,
            "daily_trades": self.state.daily_trades,
            "max_daily_trades": BOT_CONFIG.max_daily_trades,
            "daily_pnl": self.state.daily_pnl,
            "open_positions": len(self.state.open_positions),
            "last_trade": self.state.last_trade_time.isoformat() if self.state.last_trade_time else None,
            "last_error": self.state.last_error,
            "current_day": context["day_name"],
            "current_session": context["session"],
            "day_bias": context["day_rules"].get("bias", "NEUTRAL"),
            "session_strategy": context["session_rules"].get("strategy", "NEUTRAL")
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """Main entry point"""
    bot = NeoPatternBot()
    
    try:
        await bot.run()
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received")
        bot.stop()
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())
